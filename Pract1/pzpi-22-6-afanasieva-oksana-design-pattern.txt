Міністерство освіти і науки України
Харківський національний  університет радіоелектроніки

Кафедра програмної інженерії



ЗВІТ
з практичної роботи №1
з дисципліни «Архітектура програмного забезпечення»
на тему: «Патерни проєктування»

Виконала:	
ст. гр. ПЗПІ-22-6	
Афанасьєва О.М.	

Перевірив:
ст. викл. каф. ПІ
Сокорчук І.П.


Харків 2025

1 ІСТОРІЯ ЗМІН
Таблиця 1 – Історія змін 
№	Дата	Версія звіту	Опис змін та виправлень
1	27.04.2025	0.1	Створено розділ «Історія змін»
2	27.04.2025	0.1	Створено розділ «Завдання»
3	27.04.2025	0.1	Додано слайди презентації у додаток Б
4	27.04.2025	0.1	Додано програмний код, який розглядається у доповіді у додаток В
5	27.04.2025	0.1	Створено розділ «Опис виконаної роботи»
6	27.04.2025	0.1	Створено розділ «Висновки»
7	28.04.2025	0.1	Додано посилання на відеозапис та хронологічний опис доповіді у додаток А

2 ЗАВДАННЯ
1.	Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ»
2.	Створити та оформити слайди презентації доповіді
3.	Створити та опублікувати на YouTube відеозапис доповіді
4.	Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
5.	При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
6.	Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
7.	Створити у корені створеного репозиторію файл README.md з вказаним змістом та вказані директорії для окремих завдань
8.	Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
9.	Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1

3 ОПИС ВИКОНАНОЇ РОБОТИ
Патерн проєктування "Команда" – це поведінковий патерн, який перетворює запит або просту операцію на самостійний об'єкт, що містить всю інформацію про запит. Така трансформація дозволяє передавати запити як аргументи методів, ставити їх у чергу, логувати, а також підтримувати скасування операцій.
Основна ідея патерну полягає у відокремленні об'єкта, що ініціює операцію, від об'єкта, який знає, як виконати цю операцію. Це досягається шляхом інкапсуляції всієї необхідної інформації для виконання дії в окремому об'єкті-команді, який має єдиний метод без параметрів, що запускає цю дію.
Патерн "Команда" складається з таких ключових компонентів:
Відправник зберігає посилання на об’єкт команди та звертається до нього, коли потрібно виконати якусь дію. Відправник працює з командами тільки через їхній загальний інтерфейс. Він не знає, яку конкретно команду використовує, оскільки отримує готовий об’єкт команди від клієнта.
Команда описує інтерфейс, спільний для всіх конкретних команд. Зазвичай тут описується лише один метод запуску команди.
Конкретні команди реалізують різні запити, дотримуючись загального інтерфейсу команд. Як правило, команда не робить всю роботу самостійно, а лише передає виклик одержувачу, яким виступає один з об’єктів бізнес-логіки.
Параметри, з якими команда звертається до одержувача, необхідно зберігати у вигляді полів. У більшості випадків об’єкти команд можна зробити незмінними, передаючи у них всі необхідні параметри тільки через конструктор.
Одержувач містить бізнес-логіку програми. У цій ролі може виступати практично будь-який об’єкт. Зазвичай, команди перенаправляють виклики одержувачам, але іноді, щоб спростити програму, ви можете позбутися від одержувачів, «зливши» їхній код у класи команд.
Клієнт створює об’єкти конкретних команд, передаючи до них усі необхідні параметри, серед яких можуть бути і посилання на об’єкти одержувачів. Після цього клієнт зв’язує об’єкти відправників зі створеними командами.
Цей патерн має такі переваги:
-	Прибирає пряму залежність між об’єктами, що викликають операції, та об’єктами, які їх безпосередньо виконують.
-	Реалізує принцип відкритості/закритості, тобто можна додавати нові команди, не змінюючи існуючий код.
-	Дозволяє реалізувати просте скасування і повтор операцій.
-	Дозволяє реалізувати відкладений запуск операцій. Команди можна виконувати пізніше або за розкладом.
-	Дозволяє збирати складні команди з простіших.
Недоліками даного патерну є:
-	Ускладнює код програми внаслідок введення великої кількості додаткових класів.
-	Створює накладні витрати, оскільки виникає додатковий шар абстракції між викликаючим та виконуючим кодом.
-	Якщо система не потребує складних операцій або скасування, патерн може бути надмірним.
Патерн «Команда» варто використовувати у випадках:
-	Якщо є необхідність параметризувати об’єкти виконуваною дією. Команда перетворює операції на об’єкти, а об’єкти, у свою чергу, можна передавати, зберігати та взаємозаміняти всередині інших об’єктів.
-	Якщо є необхідність поставити операції в чергу, виконувати їх за розкладом або виконувати їх віддалено. Як й інші об’єкти, команди можна серіалізувати, тобто перетворити на рядок, щоб потім зберегти у файл або базу даних. Потім в будь-який зручний момент його можна дістати назад, знову перетворити на об’єкт команди та виконати. Так само команди можна передавати мережею, логувати або виконувати на віддаленому сервері.
-	Якщо є необхідність в операції скасування. Головна річ, яка потрібна для того, щоб мати можливість скасовувати операції — це зберігання історії. Історія команд виглядає як стек, до якого потрапляють усі виконані об’єкти команд. Кожна команда перед виконанням операції зберігає поточний стан об’єкта, з яким вона працюватиме. Після виконання операції копія команди потрапляє до стеку історії, продовжуючи нести у собі збережений стан об’єкта. Якщо знадобиться скасування, програма візьме останню команду з історії та відновить збережений у ній стан.

4 ВИСНОВКИ
Патерн "Команда" є потужним інструментом об'єктно-орієнтованого проєктування, який дозволяє інкапсулювати запити у об'єкти. Він особливо корисний у системах, де потрібно реалізувати скасування операцій, відкладене виконання, чергу операцій або логування змін.
Основною перевагою патерну є відокремлення об'єкта, що ініціює операцію, від об'єкта, який її виконує, що покращує модульність системи та дотримання принципів SOLID.
Проте варто пам'ятати про збільшення кількості класів при використанні цього патерну, що може ускладнити код для простих випадків. Тому важливо знайти баланс між гнучкістю, яку забезпечує патерн Command, та простотою коду.
 
ДОДАТОК А
Відеозапис та хронологічний опис

Відеозапис доповіді на YouTube: 
Хронологічний опис відеозапису:

ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд

Рисунок Б.2 – Визначення патерну Команда (Command)

Рисунок Б.3 – Структура патерну

Рисунок Б.4 – Переваги патерну

Рисунок Б.5 – Недоліки патерну

Рисунок Б.6 – Застосування патерну

Рисунок Б.7 – Приклад коду реалізації. Відправник (Invoker)

Рисунок Б.8 – Приклад коду реалізації. Інтерфейс Command

Рисунок Б.9 – Приклад коду реалізації. Конкретні команди (ConcreteCommand)

Рисунок Б.10 – Приклад коду реалізації. Одержувач (Receiver)

Рисунок Б.11 – Приклад коду використання

Рисунок Б.12 – Висновки

Рисунок Б.13 – Використані джерела

ДОДАТОК В
Програмний код

GitHub репозиторій: https://github.com/NureAfanasievaOksana/apz-pzpi-22-6-afanasieva-oksana/blob/main/Pract1/pzpi-22-6-afanasieva-oksana-design-pattern/code-examples-design-pattern.cpp
1  public class TextEditor
2  {
3      private Document _document;
4      private Stack<ICommand> _undoStack = new Stack<ICommand>();
5  
6      public TextEditor()
7      {
8          _document = new Document();
9      }
10  
11      public string GetText()
12      {
13          return _document.Text;
14      }
15  
16      public void ExecuteCommand(ICommand command)
17      {
18          command.Execute();
19          _undoStack.Push(command);
20      }
21  
22      public void Undo()
23      {
24          if (_undoStack.Count > 0)
25          {
26              ICommand command = _undoStack.Pop();
27              command.Undo();
28          }
29      }
30  
31      public Document GetDocument()
32      {
33          return _document;
34      }
35  }
36  
37  public interface ICommand
38  {
39      void Execute();
40      void Undo();
41  }
42  
43  public class InsertTextCommand : ICommand
44  {
45      private Document _document;
46      private string _text;
47      private int _i;
48      private bool _executed;
49  
50      public InsertTextCommand(Document document, string text, int i)
51      {
52          _document = document;
53          _text = text;
54          _i = i;
55          _executed = false;
56      }
57  
58      public void Execute()
59      {
60          if (!_executed)
61          {
62              _document.Insert(_text, _i);
63              _executed = true;
64          }
65      }
66  
67      public void Undo()
68      {
69          if (_executed)
70          {
71              _document.Delete(_i, _text.Length);
72              _executed = false;
73          }
74      }
75  }
76  
77  public class CopyCommand : ICommand
78  {
79      private Document _document;
80      private int _start;
81      private int _length;
82  
83      public CopyCommand(Document document, int start, int length)
84      {
85          _document = document;
86          _start = start;
87          _length = length;
88      }
89  
90      public void Execute()
91      {
92          _document.Copy(_start, _length);
93      }
94  
95      public void Undo() { }
96  }
97  
98  public class Document
99  {
100      private string _text = "";
101      private List<string> _clipboard = new List<string>();
102  
103      public string Text => _text;
104  
105      public void Insert(string text, int i)
106      {
107          _text = _text.Insert(i, text);
108          Console.WriteLine($"Text is pasted.\nCurrent text: {_text}");
109      }
110  
111      public string Delete(int start, int length)
112      {
113          string deletedText = _text.Substring(start, length);
114          _text = _text.Remove(start, length);
115          Console.WriteLine($"Text deleted.\nCurrent text: {_text}");
116          return deletedText;
117      }
118  
119      public void Copy(int start, int length)
120      {
121          _clipboard.Add( _text.Substring(start, length));
122          Console.WriteLine($"Text copied to clipboard: {_clipboard[_clipboard.Count - 1]}");
123      }
124  
125      public string GetLastClipboardItem()
126      {
127          if( _clipboard.Count > 0 )
128          {
129              return _clipboard[_clipboard.Count - 1];
130          }
131          return "";
132      }
133  }
134  
135  public class Client
136  {
137      public static void Main(string[] args)
138      {
139          TextEditor editor = new TextEditor();
140  
141          ICommand insertCommand = new InsertTextCommand(editor.GetDocument(), "Some text.", 0);
142          editor.ExecuteCommand(insertCommand);
143          
144          ICommand copyCommand = new CopyCommand(editor.GetDocument(), 0, 4);
145          editor.ExecuteCommand(copyCommand);
146  
147          ICommand insertCommand1 = new InsertTextCommand(editor.GetDocument(), "text.", 10);
148          editor.ExecuteCommand(insertCommand1);
149  
150          editor.Undo();
151      }
152  }
